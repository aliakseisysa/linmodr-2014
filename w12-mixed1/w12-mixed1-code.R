#---- Загрузка пакетов и настройка
# Для графиков
library(ggplot2)
theme_set(theme_bw(base_size = 16) +
            theme(legend.key = element_blank()))
update_geom_defaults("point", list(shape = 19, size = 3))
# для смешанных моделей
library(nlme)

#----- Загрузка данных -----
# Пример: видовое богатство на разных пляжах в зависимости от степени открытости и уровня на литорали
rikz <- read.table("RIKZ.csv", header = TRUE, sep = "\t")

#---- I. Знакомство с данными -----
head(rikz, 2)
str(rikz)

# Факторы
rikz$Beach <- factor(rikz$Beach)

# Сколько всего точек данных?
sum(complete.cases(rikz))

# Видовое богатство на разных пляжах
ggplot(rikz, aes(x = Beach, y = Richness)) + geom_boxplot()
# Видовое богатство от уровня на литорали на разных пляжах
ggplot(rikz, aes(x = NAP, y = Richness)) + geom_point(aes(colour = Beach))
# Пляжи различаются по видовому богатству
# Различия между пляжами нужно учесть во время анализа

# Есть ли наблюдения-выбросы? строим dot-plot
ggplot(rikz, aes(x = Richness, y = 1:nrow(rikz), colour = Beach)) + geom_point()
# Подозрительно большой список видов на 5-м пляже
ggplot(rikz, aes(x = NAP, y = 1:nrow(rikz))) + geom_point()
# нет выбросов среди значений NAP

# Как нам учесть изменчивость между пляжами?
# А. Модель с фиксированными факторами
# Это неправильный способ, разберемся почему
# Б. Смешанная модель (со случайными факторами)
# Правильный способ

#---- Модель с фиксированными факторами -----
# Это неправильный способ, разберемся почему
# Сколько параметров будет в модели, где фактор пляж фиксированный?

M0 <- gls(Richness ~ NAP + Beach, data = rikz, method = "REML")
summary(M0)
# Сколько параметров будет в этой модели?
length(coef(M0))
# [1] 10
# Из них на описание фактора Beach пошло 8 параметров (вдобавок к intercept)
# Обычная рекомендация - 15-20 точек данных на параметр
# Сколько всего точек данных?
sum(complete.cases(rikz[, c("Richness", "NAP", "Beach")]))
# [1] 45
# т.е. у нас по-хорошему данных отсилы на 2-3 параметра

#---- II. Смешанная модель ----
# Нам не важны различия между конкретными пляжами
# Мы хотим оценить изменчивость (разброс значений) между отдельными пляжами

#---- 1. Подбор смешанной модели -----
M1 <- lme(Richness ~ NAP, random = ~ 1 | Beach, data = rikz, method = "ML")
summary(M1)

# Все ли в порядке с моделью? Анализ остатков

# 1) График остатков от предсказанных значений
plot(M1)
rikz$.stdresid <- resid(M1, type = "n")
rikz$.fitted <- fitted(M1)
ggplot(rikz, aes(x = .fitted, y = .stdresid)) + geom_point() + aes(colour = Beach)
# Есть большие остатки, намек на гетерогенность дисперсий

# 2) График остатков от ковариат в модели
p <- ggplot(rikz, aes(y = .stdresid))
p + geom_point(aes(x = NAP)) + aes(colour = Beach)
# большой остаток у наблюдения с 5-го пляжа
p + geom_boxplot(aes(x = Beach))
# Гетерогенность дисперсий. Пока оставим все как есть

# 3) График остатков от ковариат не вошедших в модель (нет ли других нужных переменных?), если есть
p + geom_point(aes(x = Exposure)) + aes(colour = Beach)

# 4) График остатков от времени, если есть

# 5) График остатков от координат проб, если есть

#----- 2. Какие из фиксированных факторов влияют? -----
# Один из трех вариантов:

#A. По значениям t-(или -z) статистики (REML оценка)
# приблизительный результат
# годится для факторов, если не больше 2 уровней
summary(M1)
# здесь не годится - уровней больше 2

#B. F-критерий - приблизительный результат (REML оценка)
# зависит от порядка включения предикторов в модель
anova(M1)
# Годится, т.к. один предиктор
# Вывод: богатство зависит от уровня на литорали

#C. likelihood ratio test или AIC (ML оценка)
# Один из двух вариантов:

# С.1. Попарное сравнение вложенных моделей при помощи likelihood ratio test дает более точные выводы, чем F и t(z)
M1.ml <- lme(Richness ~ NAP, random = ~1|Beach, data = rikz, method = "ML")
M2.ml <- update(M1.ml, . ~ . - NAP)
anova(M1.ml, M2.ml)

# df теста - это разница df сравниваемых моделей = 6 - 3 = 3
# В тексте можно написать
# Видовое богатство меняется в зависимости от уровня на литорали
# (L = 21.47, df = 1, p < 0.01)

# С.2. Сравнение моделей по AIC
AIC(M1.ml, M2.ml)
# AIC меньше у модели с NAP, значит уровень на литорали влияет на видовое богатство

#----- 3. Представление результатов -----

# REML оценка параметров (более точна)
MFinal <- lme(Richness ~ NAP, random = ~1|Beach, method = "REML", data = rikz)

# Проверка финальной модели (те же графики, что и в п.1)
# Поскольку модель у нас не изменилась, не привожу их здесь
# Все ли в порядке с моделью? Анализ остатков
# 1) График остатков от предсказанных значений
# 2) График остатков от ковариат в модели
# 3) График остатков от ковариат не вошедших в модель (нет ли других нужных переменных?), если есть
# 4) График остатков от времени, если есть
# 5) График остатков от координат проб, если есть

#----- Запись модели -----

summary(MFinal)
# Уравнение модели
# Richness_ij = beta_0 + beta_1 * NAP_ij + a_i + e_ij
# a_i  ~ N(0, sigma_Beach^2) (случайный эффект пляжа)
# e_ij ~ N(0, sigma^2) (остатки)
#   i = 1,....., 6 (число пляжей)
#   j = 1, ..., n (число наблюдений для пляжа)

#----- Внутриклассовая корреляция -----
# мера силы влияния случайного эффекта
# формула:
# sigma_Beach^2 / (sigma_Beach^2 + sigma^2)

# В результатах summary(MFinal)
# Random effects:
# Random effects:
#   Formula: ~1 | Beach
# (Intercept) Residual
# StdDev:       2.944     3.06

# Вычисляем внутриклассовую корреляцию
2.944^2 / (2.944^2 + 3.06^2)
# [1] 0.4807
# Значения видового богатства внутри одного пляжа похожи, эффект пляжа нельзя игнорировать в анализе

#---- График предсказанных значений для результатов -----

# 1) Создаем новый датафрейм, для которого будем предсказывать
minmax <- range(rikz$NAP)
new_data <- expand.grid(NAP = seq(from = minmax[1],
                                 to = minmax[2],
                                 length=100),
            Beach = levels(rikz$Beach))

# 2) Матрица линейной модели
X <- model.matrix(~ NAP, data = new_data)

# 3) Вычисляем предсказанные значения одним из двух способов
# level = 0 - для фиксированных эффектов (т.е. без учета пляжа)
new_data$.fitted <- predict(MFinal, new_data, level = 0)
# или то же самое при помощи матриц
# Y = X * BETA
# BETA = fixef(MFinal) # это вектор значений коэффициентов при фикс. факторах
# т.е. предсказанные значения по фикс. части модели:
new_data$.fitted <- X %*% fixef(MFinal) # beta_0 + beta * NAP

# 4) Вычисляем стандартные ошибки предсказанных значений
# это квадратный корень из диагональных элементов
# матрицы ковариаций предсказанных значений X * cov(BETA) * t(X)
new_data$.se <- sqrt( diag(X %*% vcov(MFinal) %*% t(X)) )

# 5) Строим график предсказанных значений
head(new_data)
# a) график где по одной точке для каждого уровня фактора,
# +/- 95% доверит. интервал (1.98 * стандартная ошибка, которая учитывает различия между пляжами)
ggplot(new_data) +
  geom_point(data = rikz, aes(x = NAP, y = Richness)) +
  geom_ribbon(alpha = 0.2, aes(x = NAP,
                      y = .fitted,
                      ymin = .fitted - 1.98 * .se,
                      ymax = .fitted + 1.98 * .se))

# Если хотите посмотреть на предсказания для каждого пляжа - пожалуйста
# beta_0 + beta * NAP + случайный эффект пляжа
new_data$.fitted1 <- predict(MFinal, new_data, level = 1)

# Обрезаем диапазоны по оси х, чтобы не предсказывать вне области определения нашей модели
get_filter <- function(data, x_var, facet_var, new_data) {
  rng <- with(data, tapply(get(x_var), get(facet_var), range))
  filters <- mapply(FUN = function(x, y){
    new_data[new_data[, facet_var] == y, x_var] >= x[1] &
      new_data[new_data[, facet_var] == y, x_var] <= x[2]
  },
  x = rng, y = levels(new_data[, facet_var]))
  fltr <- Reduce(c, filters)
  return(fltr)
}
myfltr <- get_filter(data = rikz, x_var = "NAP",
                     facet_var = "Beach",
                     new_data = new_data)
new_data1 <- new_data[myfltr, ]

# График с предсказаниями для индивидуальных уровней случайного фактора
ggplot(new_data1, aes(x = NAP, y = .fitted1, group = Beach)) +
  geom_ribbon(aes(fill = Beach,
                  ymin = .fitted1 - 1.98 * .se,
                  ymax = .fitted1 + 1.98 * .se),
              alpha = 0.5) +
  geom_point(data = rikz, aes(x = NAP, y = Richness)) +
  geom_line() +
  facet_wrap(~Beach)

